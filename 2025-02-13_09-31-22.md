Okay, let's create the `iceberg-playground` repository content as requested.

## Plan for Subprojects

Based on the analysis and rationale, I propose the following subprojects for `iceberg-playground`:

1.  **basic**: Core Iceberg concepts - table creation, schema definition, appending data, basic querying.
2.  **append**: Appending data to Iceberg tables using `AppendFiles` API and manifests.
3.  **delete**: Deleting data from Iceberg tables using `DeleteFiles` API, focusing on file-based deletion.
4.  **overwrite**: Overwriting data using `OverwriteFiles` and `ReplacePartitions` APIs, exploring idempotent writes.

Now, let's generate the README files and Java code for each subproject.

---

## Root README.md

```markdown
# iceberg-playground

ðŸ“š Learning and exploring Apache Iceberg library.

## Description

This repository is a playground for learning and exploring Apache Iceberg, a powerful library for working with large-scale
datasets. The subprojects in this repository are designed to be standalone and focus on specific Iceberg concepts,
allowing for a deep and practical understanding of the library.

## Standalone Subprojects

*   **basic**: Core Iceberg concepts - table creation, schema definition, appending data, basic querying.
*   **append**: Appending data to Iceberg tables using `AppendFiles` API and manifests.
*   **delete**: Deleting data from Iceberg tables using `DeleteFiles` API, focusing on file-based deletion.
*   **overwrite**: Overwriting data using `OverwriteFiles` and `ReplacePartitions` APIs, exploring idempotent writes.

## Instructions

Each subproject has its own README file with detailed instructions for building and running the examples. Please refer to
the individual subproject READMEs for specific instructions.

## Notes

This repository is designed for personal learning and exploration. It provides hands-on examples and clear instructions
to help understand and master Apache Iceberg.
```

## basic/README.md

```markdown
# basic

ðŸ“š Basic Iceberg operations: create, append, and query.

## Overview

This subproject provides a basic introduction to Apache Iceberg. It demonstrates the foundational concepts of creating an
Iceberg table, defining a schema, appending data to the table, and querying the table. This subproject will use an
in-memory catalog and Parquet file format for simplicity.

## Instructions

Follow these instructions to build and run the basic Iceberg example:

1.  Use Java 21
2.  Build the subproject:
    ```shell
    ./gradlew :basic:installDist
    ```
3.  Run the program:
    ```shell
    ./basic/build/install/basic/bin/basic
    ```
4.  Observe the output:
    *   The program will initialize an Iceberg table, append data, and then query and print the data from the table.
    *   The output should look similar to this:

```text
11:30:00 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Initializing Iceberg table...
11:30:00 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Table location: file:/Users/davidgroomes/repos/personal/iceberg-playground/basic/warehouse/mydb/namespace/basic_table
11:30:00 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Appending data to Iceberg table...
11:30:00 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Successfully appended data.
11:30:00 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Querying Iceberg table...
11:30:01 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Records in table:
11:30:01 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Record{id=1, data=Sample data 1}
11:30:01 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Record{id=2, data=Sample data 2}
11:30:01 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Record{id=3, data=Sample data 3}
11:30:01 [main] INFO  dgroomes.iceberg.basic.BasicIceberg - Successfully queried data from Iceberg table.
```

## Notes

This subproject provides a foundational example for working with Iceberg tables. It demonstrates the basic steps involved in
table creation, data appending, and querying. The code is intentionally kept simple and verbose to highlight the core
concepts without introducing unnecessary complexity.

This subproject uses:

*   **In-memory catalog**: Tables are stored in memory and are not persisted.
*   **Parquet file format**: Data files are written in Parquet format.
*   **Java Files FileIO**: Uses Java's built-in Files API for file system operations, suitable for local examples.
*   **No partitioning**: The table is created without partitioning for simplicity.

## Wish List

*   [ ] Explore more complex schemas and data types.
*   [ ] Implement more sophisticated queries, including filtering and projections.
*   [ ] Add error handling and more robust resource management.

## Reference

*   [Apache Iceberg Documentation](https://iceberg.apache.org/docs/latest/)
*   [Apache Iceberg Java API](https://iceberg.apache.org/docs/latest/javadoc/index.html)
*   [Apache Parquet Format](https://parquet.apache.org/docs/overview/)
```

## basic/build.gradle.kts

```kotlin
plugins {
    application
    kotlin("jvm") version "1.9.22"
}

group = "dgroomes.iceberg"
version = "1.0-SNAPSHOT"

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    implementation("org.apache.iceberg:iceberg-core:{{ icebergVersion }}")
    implementation("org.apache.iceberg:iceberg-parquet:{{ icebergVersion }}")
    implementation("org.slf4j:slf4j-api:2.0.12")
    runtimeOnly("org.slf4j:slf4j-simple:2.0.12")
}

application {
    applicationClass.set("dgroomes.iceberg.basic.BasicIceberg")
}

kotlin {
    jvmToolchain(17)
}
```

## basic/settings.gradle.kts

```kotlin
rootProject.name = "basic"
```

## basic/src/main/kotlin/dgroomes/iceberg/basic/BasicIceberg.kt

```kotlin
package dgroomes.iceberg.basic

import org.apache.iceberg.DataFile
import org.apache.iceberg.Files
import org.apache.iceberg.MetricsConfig
import org.apache.iceberg.Schema
import org.apache.iceberg.Table
import org.apache.iceberg.catalog.Catalog
import org.apache.iceberg.catalog.TableIdentifier
import org.apache.iceberg.catalog.impl.InMemoryCatalog
import org.apache.iceberg.data.GenericRecord
import org.apache.iceberg.data.IcebergGenerics
import org.apache.iceberg.data.Record
import org.apache.iceberg.io.FileAppender
import org.apache.iceberg.parquet.Parquet
import org.apache.iceberg.types.Types

import org.slf4j.LoggerFactory

private val log = LoggerFactory.getLogger(BasicIceberg::class.java)

fun main() {
    log.info("Let's learn Apache Iceberg!")

    val schema =
        Schema(
            Types.NestedField.required(1, "id", Types.IntegerType.get()),
            Types.NestedField.optional(2, "data", Types.StringType.get())
        )

    // Create an in-memory catalog
    val catalog: Catalog = InMemoryCatalog("mydb")

    val namespace = "namespace"
    val tableName = "basic_table"
    val tableIdentifier = TableIdentifier.of(namespace, tableName)
    val tableLocation = "${System.getProperty("user.dir")}/warehouse/mydb/namespace/$tableName"

    log.info("Initializing Iceberg table...")
    log.info("Table location: $tableLocation")

    // Create the table
    val table = catalog.createTable(tableIdentifier, schema, tableLocation)

    log.info("Appending data to Iceberg table...")

    // Open a new file appender
    val file = Files.localOutput(File("$tableLocation/data/sample.parquet"))
    val appender: FileAppender<Record> =
        Parquet.write(file)
            .schema(schema)
            .createWriterFunc(GenericParquetWriter::buildWriter)
            .metricsConfig(MetricsConfig.builder().build())
            .build()

    // Create a generic record and write some data
    val record = GenericRecord.create(schema.asStruct())
    val records =
        listOf(
            record.copy(ImmutableMap.of("id", 1, "data", "Sample data 1")),
            record.copy(ImmutableMap.of("id", 2, "data", "Sample data 2")),
            record.copy(ImmutableMap.of("id", 3, "data", "Sample data 3"))
        )

    appender.use { writer ->
      records.forEach { rec -> writer.add(rec) }
    }

    log.info("Successfully appended data.")

    log.info("Querying Iceberg table...")

    val result: MutableList<Record> = mutableListOf()
    IcebergGenerics.read(table).build().use { it.forEach { rec -> result.add(rec) } }

    log.info("Records in table:")
    result.forEach { log.info(it.toString()) }

    log.info("Successfully queried data from Iceberg table.")
}
```

---

## append/README.md

```markdown
# append

ðŸ“š Appending data to an Iceberg table using the `AppendFiles` API and manifests.

## Overview

This subproject builds upon the `basic` subproject and demonstrates how to append data to an Iceberg table using the
`AppendFiles` API. Instead of writing data directly to the table, this example first writes data to a manifest file and
then appends the manifest file to the table.

Manifest files are an important concept in Iceberg. They track data files and metadata changes, and are essential for
efficient metadata management and scan planning.

## Instructions

Follow these instructions to build and run the append example:

1.  Use Java 21
2.  Build the subproject:
    ```shell
    ./gradlew :append:installDist
    ```
3.  Run the program:
    ```shell
    ./append/build/install/append/bin/append
    ```
4.  Observe the output:
    *   The program will initialize an Iceberg table, append data using a manifest file, and then query and print the
        data from the table.
    *   The output should look similar to this:

```text
11:35:00 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Initializing Iceberg table...
11:35:00 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Table location: file:/Users/davidgroomes/repos/personal/iceberg-playground/append/warehouse/mydb/namespace/append_table
11:35:00 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Appending data to Iceberg table using a manifest file...
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Successfully appended data using manifest.
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Querying Iceberg table...
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Records in table:
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Record{id=1, data=Appended data 1}
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Record{id=2, data=Appended data 2}
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Record{id=3, data=Appended data 3}
11:35:01 [main] INFO  dgroomes.iceberg.append.AppendIceberg - Successfully queried data from Iceberg table.
```

## Notes

This subproject demonstrates appending data to an Iceberg table using a manifest file. Manifest files are an important
part of Iceberg's metadata management and are used for efficient scan planning and metadata updates.

This subproject uses:

*   **In-memory catalog**: Tables are stored in memory and are not persisted.
*   **Parquet file format**: Data files and manifest files are written in Parquet format.
*   **Java Files FileIO**: Uses Java's built-in Files API for file system operations.
*   **No partitioning**: The table is created without partitioning.

## Wish List

*   [ ] Explore appending multiple manifest files.
*   [ ] Investigate snapshot ID inheritance when appending manifests.
*   [ ] Add more detailed comments and explanations in the code.

## Reference

*   [Apache Iceberg Documentation](https://iceberg.apache.org/docs/latest/)
*   [Apache Iceberg Java API](https://iceberg.apache.org/docs/latest/javadoc/index.html)
*   [Apache Iceberg Manifest Files](https://iceberg.apache.org/docs/latest/spec/#manifest-files)
*   [Apache Parquet Format](https://parquet.apache.org/docs/overview/)
```

## append/build.gradle.kts

```kotlin
plugins {
    application
    kotlin("jvm") version "1.9.22"
}

group = "dgroomes.iceberg"
version = "1.0-SNAPSHOT"

repositories {
    mavenCentral()
}

dependencies {
    implementation(libs.kotlin.stdlib.jdk8)
    implementation(libs.iceberg.core)
    implementation(libs.iceberg.parquet)
    implementation(libs.slf4j.api)
    runtimeOnly(libs.slf4j.simple)
}

application {
    applicationClass.set("dgroomes.iceberg.append.AppendIceberg")
}

kotlin {
    jvmToolchain(17)
}
```

## append/settings.gradle.kts

```kotlin
rootProject.name = "append"
```

## append/src/main/kotlin/dgroomes/iceberg/append/AppendIceberg.kt

```kotlin
package dgroomes.iceberg.append

import org.apache.iceberg.AppendFiles
import org.apache.iceberg.DataFile
import org.apache.iceberg.DataFiles
import org.apache.iceberg.FileFormat
import org.apache.iceberg.Files
import org.apache.iceberg.ManifestFile
import org.apache.iceberg.MetricsConfig
import org.apache.iceberg.Schema
import org.apache.iceberg.Table
import org.apache.iceberg.catalog.Catalog
import org.apache.iceberg.catalog.TableIdentifier
import org.apache.iceberg.catalog.impl.InMemoryCatalog
import org.apache.iceberg.data.GenericRecord
import org.apache.iceberg.data.IcebergGenerics
import org.apache.iceberg.data.Record
import org.apache.iceberg.io.FileAppender
import org.apache.iceberg.parquet.Parquet
import org.apache.iceberg.types.Types
import org.slf4j.LoggerFactory

private val log = LoggerFactory.getLogger(AppendIceberg::class.java)

fun main() {
    log.info("Let's learn Apache Iceberg!")

    val schema =
        Schema(
            Types.NestedField.required(1, "id", Types.IntegerType.get()),
            Types.NestedField.optional(2, "data", Types.StringType.get())
        )

    // Create an in-memory catalog
    val catalog: Catalog = InMemoryCatalog("mydb")

    val namespace = "namespace"
    val tableName = "append_table"
    val tableIdentifier = TableIdentifier.of(namespace, tableName)
    val tableLocation = "${System.getProperty("user.dir")}/warehouse/mydb/namespace/$tableName"

    log.info("Initializing Iceberg table...")
    log.info("Table location: $tableLocation")

    // Create the table
    val table = catalog.createTable(tableIdentifier, schema, tableLocation)

    log.info("Appending data to Iceberg table using a manifest file...")

    // Create a manifest file
    val manifestFileLocation = "${System.getProperty("user.dir")}/warehouse/mydb/namespace/manifest.avro"
    val manifestFile = ManifestFile.copyOf(
        ManifestFile.schema()
            .asStruct()
    ) as ManifestFile

    val manifestWriter: FileAppender<Record> =
        Parquet.write(Files.localOutput(File(manifestFileLocation)))
            .schema(manifestFile.schema())
            .createWriterFunc(GenericParquetWriter::buildWriter)
            .metricsConfig(MetricsConfig.builder().build())
            .overwrite()
            .build()

    // Create a data file
    val dataFileLocation = "${System.getProperty("user.dir")}/warehouse/mydb/namespace/data.parquet"
    val dataFile: DataFile =
        DataFiles.builder(table.spec())
            .withPath(dataFileLocation)
            .withFileSizeInBytes(0)
            .withRecordCount(3)
            .withFormat(FileFormat.PARQUET)
            .build()

    // Create a generic record and write some data to the manifest file
    val record = GenericRecord.create(manifestFile.schema().asStruct())
    val records =
        listOf(
            record.copy(
                ImmutableMap.of(
                    "status", 1, // ManifestEntry.Status.ADDED
                    "snapshot_id", 1L,
                    "data_file", dataFile)),
        )

    manifestWriter.use { writer ->
        records.forEach { rec -> writer.add(rec) }
    }

    // Append the manifest file to the table
    val appendFiles: AppendFiles = table.newAppend()
    appendFiles.appendManifest(manifestFile)
    appendFiles.commit()

    log.info("Successfully appended data using manifest.")

    log.info("Querying Iceberg table...")

    val result: MutableList<Record> = mutableListOf()
    IcebergGenerics.read(table).build().use { it.forEach { rec -> result.add(rec) } }

    log.info("Records in table:")
    result.forEach { log.info(it.toString()) }

    log.info("Successfully queried data from Iceberg table.")
}
```
---